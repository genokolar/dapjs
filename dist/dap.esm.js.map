{"version":3,"file":"dap.esm.js","sources":["../src/proxy/cmsis-dap.ts","../src/processor/enums.ts","../src/daplink/text-decoder.ts","../src/daplink/index.ts","../src/dap/adi.ts","../src/processor/cortex-m.ts","../src/transport/hid.ts","../src/transport/usb.ts","../src/transport/webusb.ts","../src/transport/webhid.ts"],"sourcesContent":["/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventEmitter } from 'events';\nimport { Transport } from '../transport';\nimport {\n    DAPPort,\n    DAPTransferMode,\n    DAPProtocol,\n    DAPCommand,\n    DAPConnectResponse,\n    DAPResponse,\n    DAPInfoRequest,\n    DAPResetTargeResponse,\n    DAPTransferResponse\n} from './enums';\nimport { Proxy, DAPOperation } from './';\nimport { AbortMask } from '..';\n\n/**\n * @hidden\n */\nexport const DEFAULT_CLOCK_FREQUENCY = 10000000;\n/**\n * @hidden\n */\nconst SWD_SEQUENCE = 0xE79E;\n/**\n * @hidden\n */\nconst JTAG_SEQUENCE = 0xE73C;\n\n/**\n * @hidden\n */\nconst BLOCK_HEADER_SIZE = 4;\n/**\n * @hidden\n */\nconst TRANSFER_HEADER_SIZE = 2;\n/**\n * @hidden\n */\nconst TRANSFER_OPERATION_SIZE = 5;\n\n/**\n * @hidden\n */\nclass Mutex {\n    private locked = false;\n\n    /**\n     * Wait until the Mutex is available and claim it\n     */\n    public async lock(): Promise<void> {\n        while (this.locked) {\n            // Yield the current execution context, effectively moving it to the back of the promise queue\n            await new Promise(resolve => setTimeout(resolve, 1));\n        }\n        this.locked = true;\n    }\n\n    /**\n     * Unlock the Mutex\n     */\n    public unlock(): void {\n        this.locked = false;\n    }\n}\n\n/**\n * CMSIS-DAP class\n * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__Commands__gr.html\n */\nexport class CmsisDAP extends EventEmitter implements Proxy {\n\n    /**\n     * Whether the device has been opened\n     */\n    public connected = false;\n\n    /**\n     * The maximum DAPOperations which can be transferred\n     */\n    public operationCount: number;\n\n    /**\n     * The maximum block size which can be transferred\n     */\n    public blockSize: number;\n\n    private sendMutex = new Mutex();\n\n    /**\n     * CMSIS-DAP constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(private transport: Transport, private mode: DAPProtocol = DAPProtocol.DEFAULT, private clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super();\n\n        // Determine the block size\n        this.blockSize = this.transport.packetSize - BLOCK_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER_BLOCK command\n\n        // Determine the operation count possible\n        const operationSpace = this.transport.packetSize - TRANSFER_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER command\n        this.operationCount = Math.floor(operationSpace / TRANSFER_OPERATION_SIZE);\n    }\n\n    private bufferSourceToUint8Array(prefix: number, data?: BufferSource): Uint8Array {\n\n        if (!data) {\n            return new Uint8Array([prefix]);\n        }\n\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const result = new Uint8Array(arrayBuffer.byteLength + 1);\n\n        result.set([prefix]);\n        result.set(new Uint8Array(arrayBuffer), 1);\n\n        return result;\n    }\n\n    /**\n     * Switches the CMSIS-DAP unit to use SWD\n     * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0316d/Chdhfbhc.html\n     */\n    protected async selectProtocol(protocol: DAPProtocol): Promise<void> {\n        const sequence = protocol === DAPProtocol.JTAG ? JTAG_SEQUENCE : SWD_SEQUENCE;\n\n        await this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])); // Sequence of 1's\n        await this.swjSequence(new Uint16Array([sequence]));                                // Send protocol sequence\n        await this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])); // Sequence of 1's\n        await this.swjSequence(new Uint8Array([0x00]));\n    }\n\n    /**\n     * Send a command\n     * @param command Command to send\n     * @param data Data to use\n     * @returns Promise of DataView\n     */\n    protected async send(command: number, data?: BufferSource): Promise<DataView> {\n        const array = this.bufferSourceToUint8Array(command, data);\n        await this.sendMutex.lock();\n\n        try {\n            await this.transport.write(array);\n            const response = await this.transport.read();\n\n            if (response.getUint8(0) !== command) {\n                throw new Error(`Bad response for ${command} -> ${response.getUint8(0)}`);\n            }\n\n            switch (command) {\n                case DAPCommand.DAP_DISCONNECT:\n                case DAPCommand.DAP_WRITE_ABORT:\n                case DAPCommand.DAP_DELAY:\n                case DAPCommand.DAP_RESET_TARGET:\n                case DAPCommand.DAP_SWJ_CLOCK:\n                case DAPCommand.DAP_SWJ_SEQUENCE:\n                case DAPCommand.DAP_SWD_CONFIGURE:\n                case DAPCommand.DAP_SWD_SEQUENCE:\n                case DAPCommand.DAP_SWO_TRANSPORT:\n                case DAPCommand.DAP_SWO_MODE:\n                case DAPCommand.DAP_SWO_CONTROL:\n                case DAPCommand.DAP_JTAG_CONFIGURE:\n                case DAPCommand.DAP_JTAG_ID_CODE:\n                case DAPCommand.DAP_TRANSFER_CONFIGURE:\n                    if (response.getUint8(1) !== DAPResponse.DAP_OK) {\n                        throw new Error(`Bad status for ${command} -> ${response.getUint8(1)}`);\n                    }\n            }\n\n            return response;\n        } finally {\n            this.sendMutex.unlock();\n        }\n    }\n\n    /**\n     * Clears the abort register of all error flags\n     * @param abortMask Optional AbortMask to use, otherwise clears all flags\n     */\n    protected async clearAbort(abortMask: number = AbortMask.WDERRCLR | AbortMask.STKERRCLR | AbortMask.STKCMPCLR | AbortMask.ORUNERRCLR): Promise<void> {\n        await this.send(DAPCommand.DAP_WRITE_ABORT, new Uint8Array([0, abortMask]));\n    }\n\n    /**\n     * Get DAP information\n     * @param request Type of information to get\n     * @returns Promise of number or string\n     */\n    public async dapInfo(request: DAPInfoRequest): Promise<number | string> {\n        try {\n            const result = await this.send(DAPCommand.DAP_INFO, new Uint8Array([request]));\n            const length = result.getUint8(1);\n\n            if (length === 0) {\n                // String information is not set\n                return '';\n            }\n\n            switch (request) {\n                case DAPInfoRequest.CAPABILITIES:\n                case DAPInfoRequest.PACKET_COUNT:\n                case DAPInfoRequest.PACKET_SIZE:\n                case DAPInfoRequest.SWO_TRACE_BUFFER_SIZE:\n                    // Byte\n                    if (length === 1) return result.getUint8(2);\n\n                    // Short\n                    if (length === 2) return result.getUint16(2);\n\n                    // Word\n                    if (length === 4) return result.getUint32(2);\n            }\n\n            const ascii = Array.prototype.slice.call(new Uint8Array(result.buffer, 2, length));\n            return String.fromCharCode.apply(null, ascii);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Send an SWJ Sequence\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Sequence.html\n     * @param sequence The sequence to send\n     * @returns Promise\n     */\n    /**\n     * 发送SWJ序列。\n     *\n     * @param sequence 要发送的SWJ序列。\n     * @param bitLength SWJ序列的位数，默认为sequence.byteLength * 8。\n     * @returns 返回一个Promise，无返回值。\n     * @throws 如果发送失败，则抛出异常。\n     */\n    public async swjSequence(sequence: BufferSource, bitLength: number = sequence.byteLength * 8): Promise<void> {\n        const data = this.bufferSourceToUint8Array(bitLength, sequence);\n\n        try {\n            await this.send(DAPCommand.DAP_SWJ_SEQUENCE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Send an SWJ Clock value\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Clock.html\n     * @param clock The SWJ clock value to send\n     * @returns Promise\n     */\n    public async swjClock(clock: number): Promise<void> {\n        try {\n            await this.send(DAPCommand.DAP_SWJ_CLOCK, new Uint8Array([\n                (clock & 0x000000FF),\n                (clock & 0x0000FF00) >> 8,\n                (clock & 0x00FF0000) >> 16,\n                (clock & 0xFF000000) >> 24\n            ]));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read/Write SWJ Pins\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Pins.html\n     * @param pinsOut Pin values to write\n     * @param pinSelect Maske to select output pins to change\n     * @param pinWait Time in microseconds to wait for output pin value to stabilize (0 - no wait, 1..3000000)\n     * @returns Promise\n     */\n    public async swjPins(pinsOut: number, pinSelect: number, pinWait: number): Promise<number> {\n        try {\n            const result = await this.send(DAPCommand.DAP_SWJ_PINS, new Uint8Array([\n                pinsOut,\n                pinSelect,\n                (pinWait & 0x000000FF),\n                (pinWait & 0x0000FF00) >> 8,\n                (pinWait & 0x00FF0000) >> 16,\n                (pinWait & 0xFF000000) >> 24\n            ]));\n            return result.getUint8(1);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Send Delay Command\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__Delay.html\n     * @param delay Time to delay in microseconds\n     * @returns Promise\n     */\n    public async dapDelay(delay: number): Promise<void> {\n        try {\n            await this.send(DAPCommand.DAP_DELAY, new Uint8Array([\n                (delay & 0x00FF),\n                (delay & 0xFF00) >> 8\n            ]));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Configure Transfer\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__TransferConfigure.html\n     * @param idleCycles Number of extra idle cycles after each transfer\n     * @param waitRetry Number of transfer retries after WAIT response\n     * @param matchRetry Number of retries on reads with Value Match in DAP_Transfer\n     * @returns Promise\n     */\n    public async configureTransfer(idleCycles: number, waitRetry: number, matchRetry: number): Promise<void> {\n        const data = new Uint8Array(5);\n        const view = new DataView(data.buffer);\n\n        view.setUint8(0, idleCycles);\n        view.setUint16(1, waitRetry, true);\n        view.setUint16(3, matchRetry, true);\n\n        try {\n            await this.send(DAPCommand.DAP_TRANSFER_CONFIGURE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public async connect(): Promise<void> {\n        if (this.connected === true) {\n            return;\n        }\n\n        await this.transport.open();\n\n        try {\n            await this.send(DAPCommand.DAP_SWJ_CLOCK, new Uint32Array([this.clockFrequency]));\n            const result = await this.send(DAPCommand.DAP_CONNECT, new Uint8Array([this.mode]));\n\n            if (result.getUint8(1) === DAPConnectResponse.FAILED || this.mode !== DAPProtocol.DEFAULT && result.getUint8(1) !== this.mode) {\n                throw new Error('Mode not enabled.');\n            }\n        } catch (error) {\n            await this.clearAbort();\n            await this.transport.close();\n            throw error;\n        }\n\n        try {\n            await this.configureTransfer(0, 100, 0);\n            await this.selectProtocol(DAPProtocol.SWD);\n        } catch (error) {\n            await this.transport.close();\n            throw error;\n        }\n\n        this.connected = true;\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public async disconnect(): Promise<void> {\n        if (this.connected === false) {\n            return;\n        }\n\n        try {\n            await this.send(DAPCommand.DAP_DISCONNECT);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        await this.transport.close();\n        this.connected = false;\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public async reconnect(): Promise<void> {\n        await this.disconnect();\n        await new Promise(resolve => setTimeout(resolve, 100));\n        await this.connect();\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise of whether a device specific reset sequence is implemented\n     */\n    public async reset(): Promise<boolean> {\n        try {\n            const response = await this.send(DAPCommand.DAP_RESET_TARGET);\n            return response.getUint8(2) === DAPResetTargeResponse.RESET_SEQUENCE;\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Transfer data with a single read or write operation\n     * @param port Port type (debug port or access port)\n     * @param mode Whether to read or write\n     * @param register The register to use\n     * @param value Any value to write\n     * @returns Promise of any value read\n     */\n    public transfer(port: DAPPort, mode: DAPTransferMode, register: number, value?: number): Promise<number>;\n    /**\n     * Transfer data with multiple read or write operations\n     * @param operations The operations to use\n     * @returns Promise of any values read\n     */\n    public transfer(operations: DAPOperation[]): Promise<Uint32Array>;\n    public async transfer(portOrOps: DAPPort | DAPOperation[], mode: DAPTransferMode = DAPTransferMode.READ, register: number = 0, value: number = 0): Promise<number | Uint32Array> {\n\n        let operations: DAPOperation[];\n\n        if (typeof portOrOps === 'number') {\n            operations = [{\n                port: portOrOps,\n                mode,\n                register,\n                value\n            }];\n        } else {\n            operations = portOrOps;\n        }\n\n        const data = new Uint8Array(TRANSFER_HEADER_SIZE + (operations.length * TRANSFER_OPERATION_SIZE));\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint8(1, operations.length);\n\n        operations.forEach((operation, index) => {\n            const offset = TRANSFER_HEADER_SIZE + (index * TRANSFER_OPERATION_SIZE);\n\n            // Transfer request\n            view.setUint8(offset, operation.port | operation.mode | operation.register);\n            // Transfer data\n            view.setUint32(offset + 1, operation.value || 0, true);\n        });\n\n        try {\n            const result = await this.send(DAPCommand.DAP_TRANSFER, data);\n\n            // Transfer count\n            if (result.getUint8(1) !== operations.length) {\n                throw new Error('Transfer count mismatch');\n            }\n\n            // Transfer response\n            const response = result.getUint8(2);\n            if (response === DAPTransferResponse.WAIT) {\n                throw new Error('Transfer response WAIT');\n            }\n            if (response === DAPTransferResponse.FAULT) {\n                throw new Error('Transfer response FAULT');\n            }\n            if (response === DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error('Transfer response PROTOCOL_ERROR');\n            }\n            if (response === DAPTransferResponse.VALUE_MISMATCH) {\n                throw new Error('Transfer response VALUE_MISMATCH');\n            }\n            if (response === DAPTransferResponse.NO_ACK) {\n                throw new Error('Transfer response NO_ACK');\n            }\n\n            if (typeof portOrOps === 'number') {\n                return result.getUint32(3, true);\n            }\n\n            const length = operations.length * 4;\n            return new Uint32Array(result.buffer.slice(3, 3 + length));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read a block of data from a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @returns Promise of values read\n     */\n    public transferBlock(port: DAPPort, register: number, count: number): Promise<Uint32Array>;\n    /**\n     * Write a block of data to a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @param values The values to write\n     * @returns Promise\n     */\n    public transferBlock(port: DAPPort, register: number, values: Uint32Array): Promise<undefined>;\n    public async transferBlock(port: DAPPort, register: number, countOrValues: number | Uint32Array): Promise<Uint32Array | undefined> {\n\n        let operationCount: number;\n        let mode: DAPTransferMode;\n        let dataSize = BLOCK_HEADER_SIZE;\n\n        if (typeof countOrValues === 'number') {\n            operationCount = countOrValues;\n            mode = DAPTransferMode.READ;\n        } else {\n            operationCount = countOrValues.length;\n            mode = DAPTransferMode.WRITE;\n            dataSize += countOrValues.byteLength;\n        }\n\n        const data = new Uint8Array(dataSize);\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint16(1, operationCount, true);\n        // Transfer request\n        view.setUint8(3, port | mode | register);\n\n        if (typeof countOrValues !== 'number') {\n            // Transfer data\n            countOrValues.forEach((countOrValue, index) => {\n                const offset = BLOCK_HEADER_SIZE + (index * 4);\n                // Transfer data\n                view.setUint32(offset, countOrValue, true);\n            });\n        }\n\n        try {\n            const result = await this.send(DAPCommand.DAP_TRANSFER_BLOCK, view);\n\n            // Transfer count\n            if (result.getUint16(1, true) !== operationCount) {\n                throw new Error('Transfer count mismatch');\n            }\n\n            // Transfer response\n            const response = result.getUint8(3);\n            if (response === DAPTransferResponse.WAIT) {\n                throw new Error('Transfer response WAIT');\n            }\n            if (response === DAPTransferResponse.FAULT) {\n                throw new Error('Transfer response FAULT');\n            }\n            if (response === DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error('Transfer response PROTOCOL_ERROR');\n            }\n            if (response === DAPTransferResponse.NO_ACK) {\n                throw new Error('Transfer response NO_ACK');\n            }\n\n            if (typeof countOrValues === 'number') {\n                return new Uint32Array(result.buffer.slice(4, 4 + operationCount * 4));\n            }\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        return undefined;\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n/**\n * Processor Core States\n */\nexport const enum CoreState {\n    /**\n     * The core has been reset\n     */\n    RESET,\n    /**\n     * Core is running with a lockup condition\n     */\n    LOCKUP,\n    /**\n     * The core is sleeping\n     */\n    SLEEPING,\n    /**\n     * The core is in debug state\n     */\n    DEBUG,\n    /**\n     * The core is running\n     */\n    RUNNING\n}\n\n/**\n * Processor Core Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100230_0004_00_en/way1435345987733.html\n */\nexport const enum CoreRegister {\n    /**\n     * General purpose register\n     */\n    R0 = 0,\n    /**\n     * General purpose register\n     */\n    R1 = 1,\n    /**\n     * General purpose register\n     */\n    R2 = 2,\n    /**\n     * General purpose register\n     */\n    R3 = 3,\n    /**\n     * General purpose register\n     */\n    R4 = 4,\n    /**\n     * General purpose register\n     */\n    R5 = 5,\n    /**\n     * General purpose register\n     */\n    R6 = 6,\n    /**\n     * General purpose register\n     */\n    R7 = 7,\n    /**\n     * General purpose register\n     */\n    R8 = 8,\n    /**\n     * General purpose register\n     */\n    R9 = 9,\n    /**\n     * General purpose register\n     */\n    R10 = 10,\n    /**\n     * General purpose register\n     */\n    R11 = 11,\n    /**\n     * General purpose register\n     */\n    R12 = 12,\n    /**\n     * Stack Pointer\n     */\n    SP = 13,\n    /**\n     * The Link Register\n     */\n    LR = 14,\n    /**\n     * The Program Counter\n     */\n    PC = 15,\n    /**\n     * The Program Status Register\n     */\n    PSR = 16,\n    /**\n     * Main Stack Pointer\n     */\n    MSP = 17,\n    /**\n     * Process Stack Pointer\n     */\n    PSP = 18,\n    /**\n     * Prevents activation of exceptions\n     */\n    PRIMASK = 20,\n    /**\n     * Controls the stack used\n     */\n    CONTROL = 20\n}\n\n/**\n * Debug Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100165_0201_00_en/ric1417175947147.html\n */\nexport const enum DebugRegister {\n    /**\n     * Debug Fault Status Register\n     */\n    DFSR = 0xE000ED30,\n    /**\n     * Debug Halting Control and Status Register\n     */\n    DHCSR = 0xE000EDF0,\n    /**\n     * Debug Core Register Selector Register, write only\n     */\n    DCRSR = 0xE000EDF4,\n    /**\n     * Debug Core Register Data Register\n     */\n    DCRDR = 0xE000EDF8,\n    /**\n     * Debug Exception and Monitor Control Register\n     */\n    DEMCR = 0xE000EDFC\n}\n\n/**\n * NVIC Registers\n */\nexport const enum NvicRegister {\n    /**\n     * NVIC: Interrupt Controller Type Register\n     */\n    ICT = 0xE000E004,\n    /**\n     * NVIC: CPUID Base Register\n     */\n    CPUID = 0xE000ED00,\n    /**\n     * NVIC: Application Interrupt/Reset Control Register\n     */\n    AIRCR = 0xE000ED0C,\n    /**\n     * NVIC: Debug Fault Status Register\n     */\n    DFSR = 0xE000ED30\n}\n\n/**\n * NVIC: Application Interrupt/Reset Control Register\n * @hidden\n */\nexport const enum AircrMask {\n    /**\n     * Reset Cortex-M (except Debug)\n     */\n    VECTRESET = (1 << 0),\n    /**\n     * Clear Active Vector Bit\n     */\n    VECTCLRACTIVE = (1 << 1),\n    /**\n     * Reset System (except Debug)\n     */\n    SYSRESETREQ = (1 << 2),\n    /**\n     * Write Key\n     */\n    VECTKEY = 0x05FA0000\n}\n\n/**\n * Debug Halting Control and Status Register\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337e/CEGCJAHJ.html\n * @hidden\n */\nexport const enum DhcsrMask {\n    /**\n     * Enables debug\n     */\n    C_DEBUGEN = (1 << 0),\n    /**\n     * Halts the core\n     */\n    C_HALT = (1 << 1),\n    /**\n     * Steps the core in halted debug\n     */\n    C_STEP = (1 << 2),\n    /**\n     * Mask interrupts when stepping or running in halted debug\n     */\n    C_MASKINTS = (1 << 3),\n    /**\n     * Enables Halting debug to gain control\n     */\n    C_SNAPSTALL = (1 << 5),\n    /**\n     * Register Read/Write on the Debug Core Register Selector register is available\n     */\n    S_REGRDY = (1 << 16),\n    /**\n     * The core is in debug state\n     */\n    S_HALT = (1 << 17),\n    /**\n     * Indicates that the core is sleeping\n     */\n    S_SLEEP = (1 << 18),\n    /**\n     * Core is running (not halted) and a lockup condition is present\n     */\n    S_LOCKUP = (1 << 19),\n    /**\n     * An instruction has completed since last read\n     */\n    S_RETIRE_ST = (1 << 24),\n    /**\n     * The core has been reset\n     */\n    S_RESET_ST = (1 << 25),\n    /**\n     * Debug Key\n     */\n    DBGKEY = (0xA05F << 16)\n}\n\n/**\n * Debug Fault Status Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0413d/Cihdifbf.html\n * @hidden\n */\nexport const enum DfsrMask {\n    /**\n     * Halt request flag\n     */\n    HALTED = (1 << 0),\n    /**\n     * BKPT instruction or hardware breakpoint match\n     */\n    BKPT = (1 << 1),\n    /**\n     * Data Watchpoint (DW) flag\n     */\n    DWTTRAP = (1 << 2),\n    /**\n     * Vector catch occurred\n     */\n    VCATCH = (1 << 3),\n    /**\n     * External debug request (EDBGRQ) has halted the core\n     */\n    EXTERNAL = (1 << 4)\n}\n\n/**\n * Debug Core Register Selector Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/CEGIAJBH.html\n * @hidden\n */\nexport const enum DcrsrMask {\n    /**\n     * Register write or read, write is 1\n     */\n    REGWnR = (1 << 16),\n    /**\n     * Register select - DebugReturnAddress & PSR/Flags, Execution Number, and state information\n     */\n    REGSEL = 0x1F,\n}\n\n/**\n * Debug Exception and Monitor Control Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/CEGHJDCF.html\n * @hidden\n */\nexport const enum DemcrMask {\n    /**\n     * Reset Vector Catch\n     */\n    CORERESET = (1 << 0),\n    /**\n     * Debug Trap on MMU Fault\n     */\n    MMERR = (1 << 4),\n    /**\n     * Debug Trap on No Coprocessor Fault\n     */\n    NOCPERR = (1 << 5),\n    /**\n     * Debug Trap on Checking Error Fault\n     */\n    CHKERR = (1 << 6),\n    /**\n     * Debug Trap on State Error Fault\n     */\n    STATERR = (1 << 7),\n    /**\n     * Debug Trap on Bus Error Fault\n     */\n    BUSERR = (1 << 8),\n    /**\n     * Debug Trap on Interrupt Error Fault\n     */\n    INTERR = (1 << 9),\n    /**\n     * Debug Trap on Hard Fault\n     */\n    HARDERR = (1 << 10),\n    /**\n     * Monitor Enable\n     */\n    MON_EN = (1 << 16),\n    /**\n     * Monitor Pend\n     */\n    MON_PEND = (1 << 17),\n    /**\n     * Monitor Step\n     */\n    MON_STEP = (1 << 18),\n    /**\n     * Monitor Request\n     */\n    MON_REQ = (1 << 19),\n    /**\n     * Trace Enable\n     */\n    TRCENA = (1 << 24)\n}\n\n/**\n * Flash Patch and Breakpoint Registers\n * http://infocenter.arm.com/help/topic/com.arm.doc.100165_0201_00_en/ric1417175949176.html\n * @hidden\n */\nexport const enum FPBRegister {\n    /**\n     * FlashPatch Control Register\n     */\n    FP_CTRL = 0xE0002000,\n    /**\n     * FlashPatch Remap Register\n     */\n    FP_REMAP = 0xE0002004,\n    /**\n     * FlashPatch Comparator Register0\n     */\n    FP_COMP0 = 0xE0002008,\n    /**\n     * FlashPatch Comparator Register1\n     */\n    FP_COMP1 = 0xE000200C,\n    /**\n     * FlashPatch Comparator Register2\n     */\n    FP_COMP2 = 0xE0002010,\n    /**\n     * FlashPatch Comparator Register3\n     */\n    FP_COMP3 = 0xE0002014,\n    /**\n     * FlashPatch Comparator Register4\n     */\n    FP_COMP4 = 0xE0002018,\n    /**\n     * FlashPatch Comparator Register5\n     */\n    FP_COMP5 = 0xE000201C,\n    /**\n     * FlashPatch Comparator Register6\n     */\n    FP_COMP6 = 0xE0002020,\n    /**\n     * FlashPatch Comparator Register7\n     */\n    FP_COMP7 = 0xE0002024,\n}\n\n/**\n * Flash Patch and Breakpoint Control Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/ch11s04s01.html#BABCAFAG\n * @hidden\n */\nexport enum FPBCtrlMask {\n    /**\n     * Flash patch unit enable\n     */\n    ENABLE = (1 << 0),\n    /**\n     * Key field which enables writing to the Flash Patch Control Register\n     */\n    KEY = (1 << 1)\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2020\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n// https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n\nconst PARTIAL_CHAR_TEST = /[\\xc0-\\xff][\\x80-\\xbf]*$/g;\nconst DOUBLE_BYTE_REPLACE = /[\\xc0-\\xff][\\x80-\\xbf]*/g;\n\nexport class TextDecoder {\n\n    private partialChar: string | undefined;\n\n    /**\n     * Decode an ArrayBuffer to a string, handling double-byte characters\n     * @param input The ArrayBuffer to decode\n     */\n    public decode(input: ArrayBuffer): string {\n\n        const numberArray = Array.prototype.slice.call(new Uint8Array(input));\n        let data = String.fromCodePoint.apply(undefined, numberArray);\n\n        if (this.partialChar) {\n            // Previous double-byte character was cut off\n            data = `${this.partialChar}${data}`;\n            this.partialChar = undefined;\n        }\n\n        const match = data.match(PARTIAL_CHAR_TEST);\n        if (match) {\n            // Partial double-byte character at end of string, save it and truncate data\n            const length = match[0].length;\n            this.partialChar = data.slice(-length);\n            data = data.slice(0, -length);\n        }\n\n        return data.replace(DOUBLE_BYTE_REPLACE, this.decoderReplacer);\n    }\n\n    private decoderReplacer(encoded: string): string {\n        let codePoint = encoded.codePointAt(0)! << 24;\n        const leadingOnes = Math.clz32(~codePoint);\n        let endPos = 0;\n        const stringLen = encoded.length;\n        let result = '';\n        if (leadingOnes < 5 && stringLen >= leadingOnes) {\n            codePoint = (codePoint << leadingOnes) >>> (24 + leadingOnes);\n            for (endPos = 1; endPos < leadingOnes; endPos = endPos + 1) {\n                codePoint = (codePoint << 6) | (encoded.codePointAt(endPos)! & 0x3f);\n            }\n            if (codePoint <= 0xFFFF) { // BMP code point\n                result += String.fromCodePoint(codePoint);\n            } else if (codePoint <= 0x10FFFF) {\n                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint = codePoint - 0x10000;\n                result += String.fromCodePoint(\n                    (codePoint >> 10) + 0xD800,  // highSurrogate\n                    (codePoint & 0x3ff) + 0xDC00 // lowSurrogate\n                );\n            } else endPos = 0; // to fill it in with INVALIDs\n        }\n        for (; endPos < stringLen; endPos = endPos + 1) {\n            result += '\\ufffd'; // replacement character\n        }\n        return result;\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { TextDecoder } from './text-decoder';\nimport { CmsisDAP, DAPProtocol, DEFAULT_CLOCK_FREQUENCY } from '../proxy';\nimport { Transport } from '../transport';\nimport { DAPLinkFlash, DAPLinkSerial } from './enums';\n\n/**\n * @hidden\n */\nconst DEFAULT_BAUDRATE = 9600;\n/**\n * @hidden\n */\nconst DEFAULT_SERIAL_DELAY = 100;\n/**\n * @hidden\n */\nconst DEFAULT_PAGE_SIZE = 62;\n\n/**\n * @hidden\n */\nconst decoder = new TextDecoder();\n\n/**\n * DAPLink Class\n */\nexport class DAPLink extends CmsisDAP {\n\n    /**\n     * Progress event\n     * @event\n     */\n    public static EVENT_PROGRESS: string = 'progress';\n\n    /**\n     * Serial read event\n     * @event\n     */\n    public static EVENT_SERIAL_DATA: string = 'serial';\n\n    /**\n     * @hidden\n     */\n    protected serialPolling = false;\n\n    /**\n     * @hidden\n     */\n    protected serialListeners = false;\n\n    /**\n     * DAPLink constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super(transport, mode, clockFrequency);\n\n        this.on('newListener', event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = true;\n                }\n            }\n        });\n\n        this.on('removeListener', event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = false;\n                }\n            }\n        });\n    }\n\n    /**\n     * 异步写入缓冲区数据到设备\n     *\n     * @param buffer 要写入的缓冲区数据\n     * @param pageSize 每次写入的数据块大小\n     * @param offset 写入数据的起始偏移量，默认为0\n     * @returns 返回一个Promise，无返回值\n     * @throws 如果写入过程中发生错误，则抛出异常\n     */\n    private async writeBuffer(buffer: ArrayBuffer, pageSize: number, offset: number = 0): Promise<void> {\n        const end = Math.min(buffer.byteLength, offset + pageSize);\n        const page = buffer.slice(offset, end);\n        const data = new Uint8Array(page.byteLength + 1);\n\n        data.set([page.byteLength]);\n        data.set(new Uint8Array(page), 1);\n\n        try {\n            await this.send(DAPLinkFlash.WRITE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        this.emit(DAPLink.EVENT_PROGRESS, offset / buffer.byteLength);\n        if (end < buffer.byteLength) {\n            return this.writeBuffer(buffer, pageSize, end);\n        }\n    }\n\n    /**\n     * 异步执行刷写操作\n     *\n     * @param buffer 待刷写的缓冲区，可以为 ArrayBuffer 或 ArrayBufferView 类型\n     * @param pageSize 每页的大小，默认为 DEFAULT_PAGE_SIZE (默认62)\n     * @returns 返回一个 Promise，无返回值\n     * @throws 若刷写过程中出现错误，则抛出异常\n     */\n    public async flash(buffer: BufferSource, pageSize: number = DEFAULT_PAGE_SIZE): Promise<void> {\n        /**\n         * 判断传入的参数是否为 ArrayBufferView 类型\n         *\n         * @param source 待判断的参数，可以是 ArrayBuffer 或 ArrayBufferView 类型\n         * @returns 如果参数是 ArrayBufferView 类型，则返回 true；否则返回 false\n         */\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(buffer) ? buffer.buffer : buffer;\n\n        try {\n            await this.writeBuffer(arrayBuffer, pageSize);\n            this.emit(DAPLink.EVENT_PROGRESS, 1.0);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Get the serial baud rate setting\n     * @returns Promise of baud rate\n     */\n    public async getSerialBaudrate(): Promise<number> {\n        try {\n            const result = await this.send(DAPLinkSerial.READ_SETTINGS);\n            return result.getUint32(1, true);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Set the serial baud rate setting\n     * @param baudrate The baudrate to use (defaults to 9600)\n     * @returns Promise\n     */\n    public async setSerialBaudrate(baudrate: number = DEFAULT_BAUDRATE): Promise<void> {\n        try {\n            await this.send(DAPLinkSerial.WRITE_SETTINGS, new Uint32Array([baudrate]));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Write serial data\n     * @param data The data to write\n     * @returns Promise\n     */\n    public async serialWrite(data: string): Promise<void> {\n        const arrayData = data.split('').map((e: string) => e.charCodeAt(0));\n        arrayData.unshift(arrayData.length);\n        try {\n            await this.send(DAPLinkSerial.WRITE, new Uint8Array(arrayData).buffer);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read serial data\n     * @returns Promise of any arrayBuffer read\n     */\n    public async serialRead(): Promise<ArrayBuffer | undefined> {\n        try {\n            const serialData = await this.send(DAPLinkSerial.READ);\n            // Check if there is any data returned from the device\n            if (serialData.byteLength === 0) {\n                return undefined;\n            }\n\n            // First byte contains the vendor code\n            if (serialData.getUint8(0) !== DAPLinkSerial.READ) {\n                return undefined;\n            }\n\n            // Second byte contains the actual length of data read from the device\n            const dataLength = serialData.getUint8(1);\n            if (dataLength === 0) {\n                return undefined;\n            }\n\n            const offset = 2;\n            return serialData.buffer.slice(offset, offset + dataLength);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Start listening for serial data\n     * @param serialDelay The serial delay to use (default 100)\n     * @param autoConnect whether to automatically connect to the target (default true)\n     */\n    public async startSerialRead(serialDelay: number = DEFAULT_SERIAL_DELAY, autoConnect = true) {\n        this.serialPolling = true;\n\n        while (this.serialPolling) {\n\n            // Don't read serial output unless we have event listeners\n            if (this.serialListeners) {\n\n                // Remember connection state\n                const connectedState = this.connected;\n\n                if (this.connected === false && autoConnect === true) {\n                    await this.connect();\n                }\n\n                const serialData = await this.serialRead();\n\n                // Put state back\n                if (connectedState === false && autoConnect === true) {\n                    await this.disconnect();\n                }\n\n                if (serialData !== undefined) {\n                    const data = decoder.decode(serialData);\n                    this.emit(DAPLink.EVENT_SERIAL_DATA, data);\n                }\n            }\n\n            await new Promise(resolve => setTimeout(resolve, serialDelay));\n        }\n    }\n\n    /**\n     * Stop listening for serial data\n     */\n    public stopSerialRead() {\n        this.serialPolling = false;\n    }\n}\n\nexport * from './enums';\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from '../transport';\nimport { Proxy, CmsisDAP, DAPOperation } from '../proxy';\nimport { DPRegister, APRegister, CSWMask, BankSelectMask, AbortMask, CtrlStatMask } from './enums';\nimport { DAP } from './';\nimport { DAPTransferMode, DAPPort, DAPProtocol } from '../proxy/enums';\nimport { DEFAULT_CLOCK_FREQUENCY } from '../proxy/cmsis-dap';\n\n/**\n * @hidden\n */\nconst DEFAULT_WAIT_DELAY = 100;\n\n// auto-increment beyond 1kB (10 bits) is implementation defined, see:\n// https://developer.arm.com/documentation/ihi0031/a/The-Memory-Access-Port--MEM-AP-/MEM-AP-functions/Auto-incrementing-the-Transfer-Address-Register--TAR-\nconst DEFAULT_AUTOINC_PAGESIZE = (1 << 10);\n\n/**\n * Arm Debug Interface class\n */\nexport class ADI implements DAP {\n\n    private selectedAddress?: number;\n    private cswValue?: number;\n    private proxy: Proxy;\n\n    /**\n     * ADI constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use (default 0)\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode?: DAPProtocol, clockFrequency?: number);\n    /**\n     * ADI constructor\n     * @param proxy Proxy to use\n     */\n    constructor(proxy: Proxy);\n    constructor(transportOrDap: Transport | Proxy, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        const isTransport = (test: Transport | Proxy): test is Transport => {\n            return (test as Transport).open !== undefined;\n        };\n\n        this.proxy = isTransport(transportOrDap) ? new CmsisDAP(transportOrDap, mode, clockFrequency) : transportOrDap;\n    }\n\n    /**\n     * Continually run a function until it returns true\n     * @param fn The function to run\n     * @param timeout Optional timeout to wait before giving up and throwing\n     * @param delay The milliseconds to wait between each run\n     * @returns Promise\n     */\n    protected async waitDelay(fn: () => Promise<boolean>, timeout: number = 0, delay: number = DEFAULT_WAIT_DELAY): Promise<void> {\n        let running = true;\n\n        if (timeout > 0) {\n            setTimeout(() => {\n                if (running) {\n                    running = false;\n                    throw new Error('Wait timed out');\n                }\n            }, timeout);\n        }\n\n        while (running) {\n            const result = await fn();\n            if (result === true) {\n                running = false;\n                return;\n            }\n\n            if (delay > 0) {\n                await new Promise(resolve => setTimeout(resolve, delay));\n            }\n        }\n    }\n\n    protected concatTypedArray(arrays: Uint32Array[]): Uint32Array {\n        // Only one array exists\n        if (arrays.length === 1) return arrays[0];\n\n        // Determine array length\n        let length: number = 0;\n        for (const array of arrays) {\n            length += array.length;\n        }\n\n        // Concat the arrays\n        const result = new Uint32Array(length);\n        for (let i = 0, j = 0; i < arrays.length; i++) {\n            result.set(arrays[i], j);\n            j += arrays[i].length;\n        }\n\n        return result;\n    }\n\n    protected readDPCommand(register: number): DAPOperation[] {\n        return [{\n            mode: DAPTransferMode.READ,\n            port: DAPPort.DEBUG,\n            register\n        }];\n    }\n\n    protected writeDPCommand(register: number, value: number): DAPOperation[] {\n        if (register === DPRegister.SELECT) {\n            if (value === this.selectedAddress) {\n                return [];\n            }\n            this.selectedAddress = value;\n        }\n\n        return [{\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.DEBUG,\n            register,\n            value\n        }];\n    }\n\n    protected readAPCommand(register: number): DAPOperation[] {\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.READ,\n            port: DAPPort.ACCESS,\n            register\n        });\n    }\n\n    protected writeAPCommand(register: number, value: number): DAPOperation[] {\n        if (register === APRegister.CSW) {\n            if (value === this.cswValue) {\n                return [];\n            }\n            this.cswValue = value;\n        }\n\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.ACCESS,\n            register,\n            value\n        });\n    }\n\n    protected readMem8Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_8)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem8Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_8)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.writeAPCommand(APRegister.DRW, value));\n    }\n\n    protected readMem16Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem16Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.writeAPCommand(APRegister.DRW, value));\n    }\n\n    protected readMem32Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem32Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n            .concat(this.writeAPCommand(APRegister.TAR, register))\n            .concat(this.writeAPCommand(APRegister.DRW, value as number));\n    }\n\n    protected async transferSequence(operations: DAPOperation[][]): Promise<Uint32Array> {\n        // Flatten operations into single array\n        let merged: DAPOperation[] = [];\n        merged = merged.concat(...operations);\n\n        const results: Uint32Array[] = [];\n\n        // Split operations into sequences no longer than operation count\n        while (merged.length) {\n            const sequence = merged.splice(0, this.proxy.operationCount);\n            const result = await this.proxy.transfer(sequence);\n            results.push(result);\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public async connect() {\n        const mask = CtrlStatMask.CDBGPWRUPACK | CtrlStatMask.CSYSPWRUPACK;\n\n        await this.proxy.connect();\n        await this.readDP(DPRegister.DPIDR);\n        await this.transferSequence([\n            this.writeDPCommand(DPRegister.ABORT, AbortMask.STKERRCLR), // clear sticky error\n            this.writeDPCommand(DPRegister.SELECT, APRegister.CSW), // select CTRL_STAT\n            this.writeDPCommand(DPRegister.CTRL_STAT, CtrlStatMask.CSYSPWRUPREQ | CtrlStatMask.CDBGPWRUPREQ)\n        ]);\n\n        // Wait until system and debug have powered up\n        await this.waitDelay(async () => {\n            const status = await this.readDP(DPRegister.CTRL_STAT);\n            return (status & mask) === mask;\n        });\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public disconnect(): Promise<void> {\n        return this.proxy.disconnect();\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public async reconnect(): Promise<void> {\n        await this.disconnect();\n        await new Promise(resolve => setTimeout(resolve, DEFAULT_WAIT_DELAY));\n        await this.connect();\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise\n     */\n    public reset(): Promise<boolean> {\n        return this.proxy.reset();\n    }\n\n    /**\n     * Read from a debug port register\n     * @param register DP register to read\n     * @returns Promise of register value\n     */\n    public async readDP(register: DPRegister): Promise<number> {\n        const result = await this.proxy.transfer(this.readDPCommand(register));\n        return result[0];\n    }\n\n    /**\n     * Write to a debug port register\n     * @param register DP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public async writeDP(register: DPRegister, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeDPCommand(register, value));\n    }\n\n    /**\n     * Read from an access port register\n     * @param register AP register to read\n     * @returns Promise of register value\n     */\n    public async readAP(register: APRegister): Promise<number> {\n        const result = await this.proxy.transfer(this.readAPCommand(register));\n        return result[0];\n    }\n\n    /**\n     * Write to an access port register\n     * @param register AP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public async writeAP(register: APRegister, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeAPCommand(register, value));\n    }\n\n    /**\n     * Read an 8-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem8(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem8Command(register));\n        return result[0] as number >> ((register & 0x03) << 3) & 0xFF;\n    }\n\n    /**\n     * Write an 8-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem8(register: number, value: number): Promise<void> {\n        value = value as number << ((register & 0x03) << 3);\n        await this.proxy.transfer(this.writeMem8Command(register, value));\n    }\n\n    /**\n     * Read a 16-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem16(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem16Command(register));\n        return result[0] as number >> ((register & 0x02) << 3) & 0xFFFF;\n    }\n\n    /**\n     * Write a 16-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem16(register: number, value: number): Promise<void> {\n        value = value as number << ((register & 0x02) << 3);\n        await this.proxy.transfer(this.writeMem16Command(register, value));\n    }\n\n    /**\n     * Read a 32-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem32(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem32Command(register));\n        return result[0];\n    }\n\n    /**\n     * Write a 32-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem32(register: number, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeMem32Command(register, value));\n    }\n\n    /**\n     * Read a sequence of 32-bit words from a memory access port register, without crossing TAR auto-increment boundaries\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    protected async readMem32Sequence(register: number, count: number): Promise<Uint32Array> {\n        await this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register)\n        ]);\n\n        const results: Uint32Array[] = [];\n\n        // Split into requests no longer than block size\n        let remainder = count;\n        while (remainder > 0) {\n            const chunkSize = Math.min(remainder, Math.floor(this.proxy.blockSize / 4));\n            const result = await this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunkSize);\n            results.push(result);\n            remainder -= chunkSize;\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Write a sequence of 32-bit words to a memory access port register, without crossing TAR auto-increment boundaries\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    protected async writeMem32Sequence(register: number, values: Uint32Array): Promise<void> {\n        await this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register)\n        ]);\n\n        // Split values into chunks no longer than block size\n        let index = 0;\n        while (index < values.length) {\n            const chunk = values.slice(index, index + Math.floor(this.proxy.blockSize / 4));\n            await this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunk);\n            index += Math.floor(this.proxy.blockSize / 4);\n        }\n    }\n\n    /**\n     * Read a block of 32-bit words from a memory access port register\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public async readBlock(register: number, count: number): Promise<Uint32Array> {\n        const results: Uint32Array[] = [];\n\n        // Split into reads that do not cross TAR autoincrement boundaries\n        let remainder = count;\n        while (remainder > 0) {\n            const nextPageOffset = DEFAULT_AUTOINC_PAGESIZE - (register % DEFAULT_AUTOINC_PAGESIZE);\n            const chunkSize = Math.min(remainder, nextPageOffset / 4);\n            const result = await this.readMem32Sequence(register, chunkSize);\n            results.push(result);\n            register += chunkSize * 4;\n            remainder -= chunkSize;\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Write a block of 32-bit words to a memory access port register\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public async writeBlock(register: number, values: Uint32Array): Promise<void> {\n        // Split into writes that do not cross TAR autoincrement boundaries\n        let index = 0;\n        while (index < values.length) {\n            const nextPageOffset = DEFAULT_AUTOINC_PAGESIZE - (register % DEFAULT_AUTOINC_PAGESIZE);\n            const chunkSize = Math.min(values.length - index, nextPageOffset / 4);\n            const chunk = values.slice(index, index + chunkSize);\n            await this.writeMem32Sequence(register, chunk);\n            register += chunkSize * 4;\n            index += chunkSize;\n        }\n    }\n\n    /**\n     * Read a block of bytes from a memory access port register\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public async readBytes(register: number, count: number): Promise<Uint8Array> {\n        // read a word-aligned chunk of 32-bit words containing the requested range, then trim it\n        let bytesToRead = count;\n        const startOffset = register & 0x03;\n        const endOffset = (register + count) & 0x03;\n\n        // include left-most 32-bit word\n        if (startOffset) {\n            register -= startOffset;\n            bytesToRead += startOffset;\n        }\n\n        // include right-most 32-bit word\n        if (endOffset) {\n            bytesToRead += (4 - endOffset);\n        }\n\n        const result = await this.readBlock(register, bytesToRead / 4);\n        return new Uint8Array(result.buffer).slice(startOffset, startOffset + count);\n    }\n\n    /**\n     * Write a block of bytes to a memory access port register\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public async writeBytes(register: number, values: Uint8Array): Promise<void> {\n        let bytesToWrite = values.length;\n        let index = 0;\n\n        // initial byte write\n        if ((bytesToWrite > 0) && (register & 0x01)) {\n            await this.writeMem8(register, values[index]);\n            bytesToWrite -= 1;\n            register += 1;\n            index += 1;\n        }\n\n        // initial 16-bit word write\n        if ((bytesToWrite > 1) && (register & 0x02)) {\n            await this.writeMem16(register, values[index] | (values[index + 1] << 8));\n            bytesToWrite -= 2;\n            register += 2;\n            index += 2;\n        }\n\n        // chunk of word-aligned 32-bit words\n        if (bytesToWrite >= 4) {\n            const chunkSize = bytesToWrite - bytesToWrite % 4;\n            const chunk = new Uint32Array(values.slice(index, index + chunkSize).buffer);\n            await this.writeBlock(register, chunk);\n            bytesToWrite -= chunkSize;\n            register += chunkSize;\n            index += chunkSize;\n        }\n\n        // trailing 16-bit word write\n        if (bytesToWrite > 1) {\n            await this.writeMem16(register, values[index] | (values[index + 1] << 8));\n            bytesToWrite -= 2;\n            register += 2;\n            index += 2;\n        }\n\n        // tailing byte write\n        if (bytesToWrite > 0) {\n            await this.writeMem8(register, values[index]);\n        }\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { ADI } from '../dap';\nimport {\n    DebugRegister,\n    CoreRegister,\n    DhcsrMask,\n    DfsrMask,\n    DcrsrMask,\n    CoreState,\n    NvicRegister,\n    AircrMask,\n    DemcrMask\n} from './enums';\nimport { Processor } from './';\nimport { DAPOperation } from '../proxy';\n\n/**\n * @hidden\n */\nconst EXECUTE_TIMEOUT = 10000;\n/**\n * @hidden\n */\nconst BKPT_INSTRUCTION = 0xBE2A;\n/**\n * @hidden\n */\nconst GENERAL_REGISTER_COUNT = 12;\n\n/**\n * Cortex M class\n */\nexport class CortexM extends ADI implements Processor {\n\n    private enableDebug() {\n        return this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN);\n    }\n\n    protected readCoreRegisterCommand(register: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRSR, register)\n            .concat(this.readMem32Command(DebugRegister.DHCSR))\n            .concat(this.readMem32Command(DebugRegister.DCRDR));\n    }\n\n    protected writeCoreRegisterCommand(register: number, value: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRDR, value)\n            .concat(this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR));\n    }\n\n    /**\n     * Get the state of the processor core\n     * @returns Promise of CoreState\n     */\n    public async getState(): Promise<CoreState> {\n        const dhcsr = await this.readMem32(DebugRegister.DHCSR);\n        let state: CoreState;\n\n        if (dhcsr & DhcsrMask.S_LOCKUP) state = CoreState.LOCKUP;\n        else if (dhcsr & DhcsrMask.S_SLEEP) state = CoreState.SLEEPING;\n        else if (dhcsr & DhcsrMask.S_HALT) state = CoreState.DEBUG;\n        else state = CoreState.RUNNING;\n\n        if (dhcsr & DhcsrMask.S_RESET_ST) {\n            // The core has been reset, check if an instruction has run\n            const newDhcsr = await this.readMem32(DebugRegister.DHCSR);\n            if (newDhcsr & DhcsrMask.S_RESET_ST && !(newDhcsr & DhcsrMask.S_RETIRE_ST)) {\n                return CoreState.RESET;\n            } else {\n                return state;\n            }\n        } else {\n            return state;\n        }\n    }\n\n    /**\n     * Whether the target is halted\n     * @returns Promise of halted state\n     */\n    public async isHalted(): Promise<boolean> {\n        const dhcsr = await this.readMem32(DebugRegister.DHCSR);\n        return !!(dhcsr & DhcsrMask.S_HALT);\n    }\n\n    /**\n     * Halt the target\n     * @param wait Wait until halted before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public async halt(wait: boolean = true, timeout: number = 0): Promise<void> {\n        const halted = await this.isHalted();\n\n        if (halted) {\n            return;\n        }\n\n        await this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN | DhcsrMask.C_HALT);\n\n        if (!wait) {\n            return;\n        }\n\n        return this.waitDelay(() => this.isHalted(), timeout);\n    }\n\n    /**\n     * Resume a target\n     * @param wait Wait until resumed before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public async resume(wait: boolean = true, timeout: number = 0) {\n        const halted = await this.isHalted();\n\n        if (!halted) {\n            return;\n        }\n\n        await this.writeMem32(DebugRegister.DFSR, DfsrMask.DWTTRAP | DfsrMask.BKPT | DfsrMask.HALTED);\n        await this.enableDebug();\n\n        if (!wait) {\n            return;\n        }\n\n        return this.waitDelay(async () => {\n            const result = await this.isHalted();\n            return !result;\n        }, timeout);\n    }\n\n    /**\n     * Read from a core register\n     * @param register The register to read\n     * @returns Promise of value\n     */\n    public async readCoreRegister(register: CoreRegister): Promise<number> {\n        const results = await this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRSR, register),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ]);\n\n        const dhcsr = results[0];\n        if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n            throw new Error('Register not ready');\n        }\n\n        return this.readMem32(DebugRegister.DCRDR);\n    }\n\n    /**\n     * Read an array of core registers\n     * @param registers The registers to read\n     * @returns Promise of register values in an array\n     */\n    public async readCoreRegisters(registers: CoreRegister[]): Promise<number[]> {\n        const results: number[] = [];\n\n        for (const register of registers) {\n            const result = await this.readCoreRegister(register);\n            results.push(result);\n        }\n\n        return results;\n    }\n\n    /**\n     * Write to a core register\n     * @param register The register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeCoreRegister(register: CoreRegister, value: number): Promise<void> {\n        const results = await this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRDR, value),\n            this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ]);\n\n        const dhcsr = results[0];\n        if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n            throw new Error('Register not ready');\n        }\n    }\n\n    /**\n     * Exucute code at a specified memory address\n     * @param address The address to put the code\n     * @param code The code to use\n     * @param stackPointer The stack pointer to use\n     * @param programCounter The program counter to use\n     * @param linkRegister The link register to use (defaults to address + 1)\n     * @param registers Values to add to the general purpose registers, R0, R1, R2, etc.\n     */\n    public async execute(address: number, code: Uint32Array, stackPointer: number, programCounter: number, linkRegister: number = address + 1, ...registers: number[]): Promise<void> {\n        // Ensure a breakpoint exists at the end of the code\n        if (code[code.length - 1] !== BKPT_INSTRUCTION) {\n            const newCode = new Uint32Array(code.length + 1);\n            newCode.set(code);\n            newCode.set([BKPT_INSTRUCTION], code.length - 1);\n            code = newCode;\n        }\n\n        // Create sequence of core register writes\n        const sequence = [\n            this.writeCoreRegisterCommand(CoreRegister.SP, stackPointer),\n            this.writeCoreRegisterCommand(CoreRegister.PC, programCounter),\n            this.writeCoreRegisterCommand(CoreRegister.LR, linkRegister)\n        ];\n\n        // Add in register values R0, R1, R2, etc.\n        for (let i = 0; i < Math.min(registers.length, GENERAL_REGISTER_COUNT); i++) {\n            sequence.push(this.writeCoreRegisterCommand(i, registers[i]));\n        }\n\n        // Add xPSR.\n        sequence.push(this.writeCoreRegisterCommand(CoreRegister.PSR, 0x01000000));\n\n        await this.halt(); // Halt the target\n        await this.transferSequence(sequence); // Write the registers\n        await this.writeBlock(address, code); // Write the code to the address\n        await this.resume(false); // Resume the target, without waiting\n        await this.waitDelay(() => this.isHalted(), EXECUTE_TIMEOUT); // Wait for the target to halt on the breakpoint\n    }\n\n    /**\n     * soft reset the target\n     * @param None\n     * @returns Promise\n     */\n    public async softReset(): Promise<void> {\n        await this.writeMem32(DebugRegister.DEMCR, 0);\n        return this.writeMem32(NvicRegister.AIRCR, AircrMask.VECTKEY | AircrMask.SYSRESETREQ);\n    }\n\n    /**\n     * set the target to reset state\n     * @param hardwareReset use hardware reset pin or software reset\n     * @returns Promise\n     */\n    public async setTargetResetState(hardwareReset: boolean = true): Promise<void> {\n        await this.writeMem32(DebugRegister.DEMCR, DemcrMask.CORERESET);\n\n        if (hardwareReset === true) {\n            await this.reset();\n        } else {\n            const value = await this.readMem32(NvicRegister.AIRCR);\n            await this.writeMem32(NvicRegister.AIRCR, AircrMask.VECTKEY | value | AircrMask.SYSRESETREQ);\n        }\n\n        await this.writeMem32(DebugRegister.DEMCR, 0);\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { platform } from 'os';\nimport type { HID as nodeHID } from 'node-hid';\nimport { Transport } from './';\n\n/**\n * HID Transport class\n */\nexport class HID implements Transport {\n\n    private os: string = platform();\n    public readonly packetSize = 64;\n\n    /**\n     * HID constructor\n     * @param path Path to HID device to use\n     */\n    constructor(private device: nodeHID) {\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        return;\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public async close(): Promise<void> {\n        this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        const array = await new Promise<number[]>((resolve, reject) => {\n            this.device!.read((error: string, data: number[]) => {\n                if (error) {\n                    return reject(new Error(error));\n                } else {\n                    resolve(data);\n                }\n            });\n        });\n\n        const buffer = new Uint8Array(array).buffer;\n        return new DataView(buffer);\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const array = Array.prototype.slice.call(new Uint8Array(arrayBuffer));\n\n        // Pad to packet size\n        while (array.length < this.packetSize) array.push(0);\n\n        // Windows requires the prepend of an extra byte\n        // https://github.com/node-hid/node-hid/blob/master/README.md#prepend-byte-to-hid_write\n        if (this.os === 'win32') {\n            array.unshift(0);  // prepend throwaway byte\n        }\n\n        const bytesWritten = this.device.write(array);\n        if (bytesWritten !== array.length) {\n            throw new Error('Incorrect bytecount written');\n        }\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport type { Device, InEndpoint, OutEndpoint} from 'usb';\nimport { Transport } from './';\n\n/**\n * @hidden\n */\nconst LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5);\n/**\n * @hidden\n */\nconst LIBUSB_RECIPIENT_INTERFACE = 0x01;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_OUT = 0x00;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_IN = 0x80;\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * USB Transport class\n */\nexport class USB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: InEndpoint;\n    private endpointOut?: OutEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * USB constructor\n     * @param device USB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: Device, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private bufferToDataView(buffer: Buffer): DataView {\n        const arrayBuffer = new Uint8Array(buffer).buffer;\n        return new DataView(arrayBuffer);\n    }\n\n    private isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n        return (source as ArrayBufferView).buffer !== undefined;\n    }\n\n    private bufferSourceToBuffer(bufferSource: ArrayBuffer | ArrayBufferView): Buffer {\n        const arrayBuffer = this.isView(bufferSource) ? bufferSource.buffer : bufferSource;\n        return Buffer.from(arrayBuffer);\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        const arrayBuffer = this.isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        this.device.open();\n\n        await new Promise<void>((resolve, reject) => {\n            this.device.setConfiguration(this.configuration, error => {\n                if (error) {\n                    reject(new Error(error.message));\n                } else {\n                    resolve();\n                }\n            });\n        });\n\n        const interfaces = this.device.interfaces?.filter(iface => {\n            return iface.descriptor.bInterfaceClass === this.interfaceClass;\n        });\n\n        if (!interfaces?.length) {\n            throw new Error('No valid interfaces found.');\n        }\n\n        // Prefer interface with endpoints\n        let selectedInterface = interfaces.find(iface => iface.endpoints.length > 0);\n\n        // Otherwise use the first\n        if (!selectedInterface) {\n            selectedInterface = interfaces[0];\n        }\n\n        this.interfaceNumber = selectedInterface.interfaceNumber;\n\n        // If we always want to use control transfer, don't find/set endpoints and claim interface\n        if (!this.alwaysControlTransfer) {\n            const endpoints = selectedInterface.endpoints;\n\n            this.endpointIn = undefined;\n            this.endpointOut = undefined;\n\n            for (const endpoint of endpoints) {\n                if (endpoint.direction === 'in' && !this.endpointIn) this.endpointIn = (endpoint as InEndpoint);\n                else if (endpoint.direction === 'out' && !this.endpointOut) this.endpointOut = (endpoint as OutEndpoint);\n            }\n\n            // If endpoints are found, claim the interface\n            if (this.endpointIn || this.endpointOut) {\n\n                // If the interface can't be claimed, use control transfer\n                try {\n                    selectedInterface.claim();\n                } catch (_e) {\n                    this.endpointIn = undefined;\n                    this.endpointOut = undefined;\n                }\n            }\n        }\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public async close(): Promise<void> {\n        this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const result = await new Promise<Buffer>((resolve, reject) => {\n            // Use endpoint if it exists\n            if (this.endpointIn) {\n                this.endpointIn.transfer(this.packetSize, (exception, buffer) => {\n                    if (exception) {\n                        reject(exception);\n                    } else {\n                        if (buffer !== undefined) {\n                            resolve(buffer);\n                        } else {\n                            resolve(new Buffer(0));\n                        }\n                    }\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                GET_REPORT,\n                IN_REPORT,\n                this.interfaceNumber!,\n                this.packetSize,\n                (exception, buffer) => {\n                    if (exception) {\n                        reject(exception);\n                    } else if (!buffer) {\n                        reject(new Error('No buffer read'));\n                    } else {\n                        // Buffer type for IN transfer\n                        resolve(buffer as Buffer);\n                    }\n                }\n            );\n        });\n\n        return this.bufferToDataView(result);\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const extended = this.extendBuffer(data, this.packetSize);\n        const buffer = this.bufferSourceToBuffer(extended);\n\n        await new Promise<void>((resolve, reject) => {\n            // Use endpoint if it exists\n            if (this.endpointOut) {\n                this.endpointOut.transfer(buffer, exception => {\n                    if (exception) {\n                        return reject(exception);\n                    } else {\n                        resolve();\n                    }\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                SET_REPORT,\n                OUT_REPORT,\n                this.interfaceNumber!,\n                buffer,\n                exception => {\n                    if (exception) {\n                        return reject(exception);\n                    } else {\n                        resolve();\n                    }\n                }\n            );\n        });\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from './';\n\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * WebUSB Transport class\n * https://wicg.github.io/webusb/\n */\nexport class WebUSB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: USBEndpoint;\n    private endpointOut?: USBEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * WebUSB constructor\n     * @param device WebUSB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: USBDevice, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        await this.device.open();\n        await this.device.selectConfiguration(this.configuration);\n\n        const interfaces = this.device.configuration!.interfaces.filter(iface => {\n            return iface.alternates[0].interfaceClass === this.interfaceClass;\n        });\n\n        if (!interfaces.length) {\n            throw new Error('No valid interfaces found.');\n        }\n\n        // Prefer interface with endpoints\n        let selectedInterface = interfaces.find(iface => iface.alternates[0].endpoints.length > 0);\n\n        // Otherwise use the first\n        if (!selectedInterface) {\n            selectedInterface = interfaces[0];\n        }\n\n        this.interfaceNumber = selectedInterface.interfaceNumber;\n\n        // If we always want to use control transfer, don't find/set endpoints and claim interface\n        if (!this.alwaysControlTransfer) {\n            const endpoints = selectedInterface.alternates[0].endpoints;\n\n            this.endpointIn = undefined;\n            this.endpointOut = undefined;\n\n            for (const endpoint of endpoints) {\n                if (endpoint.direction === 'in' && !this.endpointIn) this.endpointIn = endpoint;\n                else if (endpoint.direction === 'out' && !this.endpointOut) this.endpointOut = endpoint;\n            }\n        }\n\n        return this.device.claimInterface(this.interfaceNumber);\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public close(): Promise<void> {\n        return this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        let result: USBInTransferResult;\n\n        if (this.endpointIn) {\n            // Use endpoint if it exists\n            result = await this.device.transferIn(\n                this.endpointIn.endpointNumber,\n                this.packetSize\n            );\n        } else {\n            // Fallback to using control transfer\n            result = await this.device.controlTransferIn(\n                {\n                    requestType: 'class',\n                    recipient: 'interface',\n                    request: GET_REPORT,\n                    value: IN_REPORT,\n                    index: this.interfaceNumber\n                },\n                this.packetSize\n            );\n        }\n\n        return result.data!;\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const buffer = this.extendBuffer(data, this.packetSize);\n\n        if (this.endpointOut) {\n            // Use endpoint if it exists\n            await this.device.transferOut(\n                this.endpointOut.endpointNumber,\n                buffer\n            );\n        } else {\n            // Fallback to using control transfer\n            await this.device.controlTransferOut(\n                {\n                    requestType: 'class',\n                    recipient: 'interface',\n                    request: SET_REPORT,\n                    value: OUT_REPORT,\n                    index: this.interfaceNumber\n                },\n                buffer\n            );\n        }\n    }\n}\n","import { Transport } from './';\n\ninterface HIDDevice extends EventTarget {\n    oninputreport: ((this: HIDDevice, ev: HIDInputReportEvent) => any) | null;\n    readonly opened: boolean;\n    readonly vendorId: number;\n    readonly productId: number;\n    readonly productName: string;\n    readonly collections: readonly HIDCollectionInfo[];\n\n    open(): Promise<void>;\n    close(): Promise<void>;\n    forget(): Promise<void>;\n    sendReport(reportId: number, data: ArrayBufferView | ArrayBuffer): Promise<void>;\n    sendFeatureReport(reportId: number, data: ArrayBufferView | ArrayBuffer): Promise<void>;\n    receiveFeatureReport(reportId: number): Promise<DataView>;\n}\n\ninterface HIDInputReportEvent extends Event {\n    readonly device: HIDDevice;\n    readonly reportId: number;\n    readonly data: DataView;\n}\n\ninterface HIDCollectionInfo {\n    usage: number;\n    usagePage: number;\n    reportId: number;\n    inputReports: number;\n    outputReports: number;\n    featureReports: number;\n}\n\n/**\n * @hidden\n */\n\n/**\n * WebHID Transport class\n */\nexport class WebHID implements Transport {\n    public readonly packetSize = 64;\n\n    /**\n     * WebHID constructor\n     * @param device WebHID device to use\n     * @param reportId Report ID to use\n     */\n    constructor(private device: HIDDevice) {\n    }\n\n    /**\n     * 扩展缓冲区\n     *\n     * @param data 缓冲区数据源\n     * @param packetSize 数据包大小\n     * @returns 扩展后的缓冲区\n     */\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        // eslint-disable-next-line no-console\n        console.log('Opening device:', this.device);\n        await this.device.open();\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public async close(): Promise<void> {\n        // eslint-disable-next-line no-console\n        console.log('Closeing device:', this.device);\n        await this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        const dataView = await new Promise<DataView>(resolve => {\n            this.device.oninputreport = function (this: HIDDevice, ev: HIDInputReportEvent) {\n                resolve(ev.data);\n            };\n        });\n\n        return dataView;\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n\n        const buffer = this.extendBuffer(data, this.packetSize);\n        await this.device.sendReport(0x00, buffer);\n    }\n}\n"],"names":["FPBCtrlMask","DEFAULT_CLOCK_FREQUENCY","Mutex","this","locked","prototype","lock","Promise","resolve","setTimeout","_a","sent","unlock","CmsisDAP","_super","transport","mode","clockFrequency","_this","connected","sendMutex","blockSize","packetSize","operationSpace","operationCount","Math","floor","__extends","bufferSourceToUint8Array","prefix","data","Uint8Array","arrayBuffer","undefined","buffer","result","byteLength","set","selectProtocol","protocol","sequence","swjSequence","Uint16Array","send","command","array","write","read","response","getUint8","Error","concat","clearAbort","abortMask","dapInfo","request","length_1","getUint16","getUint32","ascii","Array","slice","call","String","fromCharCode","apply","error_1","sequence_1","__awaiter","arguments","bitLength","error_2","swjClock","clock","error_3","swjPins","pinsOut","pinSelect","pinWait","error_4","dapDelay","delay","error_5","configureTransfer","idleCycles","waitRetry","matchRetry","view","DataView","setUint8","setUint16","error_6","connect","open","Uint32Array","close","error_7","error_8","disconnect","error_9","reconnect","reset","error_10","transfer","portOrOps_1","portOrOps","register","value","operations","port","length","forEach","operation","index","offset","setUint32","length_2","error_11","transferBlock","countOrValues","dataSize","countOrValue","error_12","EventEmitter","PARTIAL_CHAR_TEST","DOUBLE_BYTE_REPLACE","TextDecoder","decode","input","numberArray","fromCodePoint","partialChar","match","replace","decoderReplacer","encoded","codePoint","codePointAt","leadingOnes","clz32","endPos","stringLen","decoder","DAPLink","serialPolling","serialListeners","on","event","EVENT_SERIAL_DATA","listenerCount","writeBuffer","buffer_1","pageSize_1","pageSize","end","min","page","emit","EVENT_PROGRESS","flash","source","isView","getSerialBaudrate","setSerialBaudrate","baudrate","serialWrite","arrayData","split","map","e","charCodeAt","unshift","serialRead","serialData","dataLength","startSerialRead","serialDelay","autoConnect","connectedState","stopSerialRead","DEFAULT_AUTOINC_PAGESIZE","ADI","transportOrDap","proxy","waitDelay","fn_1","fn","timeout","running","concatTypedArray","arrays","_i","arrays_1","i","j","readDPCommand","writeDPCommand","selectedAddress","readAPCommand","address","writeAPCommand","cswValue","readMem8Command","writeMem8Command","readMem16Command","writeMem16Command","readMem32Command","writeMem32Command","transferSequence","merged","results","splice","push","mask","readDP","writeDP","readAP","writeAP","readMem8","writeMem8","readMem16","writeMem16","readMem32","writeMem32","readMem32Sequence","count","remainder","chunkSize","writeMem32Sequence","values","chunk","readBlock","nextPageOffset","writeBlock","readBytes","bytesToRead","endOffset","startOffset","writeBytes","bytesToWrite","CortexM","enableDebug","readCoreRegisterCommand","writeCoreRegisterCommand","getState","dhcsr","state","newDhcsr","isHalted","halt","wait","resume","readCoreRegister","readCoreRegisters","registers","registers_1","writeCoreRegister","execute","address_1","code_1","stackPointer_1","programCounter_1","code","stackPointer","programCounter","linkRegister","newCode","softReset","setTargetResetState","hardwareReset","HID","device","os","reject","error","USB","interfaceClass","configuration","alwaysControlTransfer","bufferToDataView","bufferSourceToBuffer","bufferSource","Buffer","from","extendBuffer","setConfiguration","message","_b","interfaces","filter","iface","descriptor","bInterfaceClass","selectedInterface","find","endpoints","interfaceNumber","endpointIn","endpointOut","endpoints_1","endpoint","direction","claim","_e","exception","controlTransfer","LIBUSB_ENDPOINT_IN","extended","LIBUSB_ENDPOINT_OUT","WebUSB","selectConfiguration","alternates","claimInterface","transferIn","endpointNumber","controlTransferIn","requestType","recipient","transferOut","controlTransferOut","WebHID","console","log","oninputreport","ev","sendReport"],"mappings":"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"}